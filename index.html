<!DOCTYPE html>
<html lang="en">
<head>
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/modern-business.css" rel="stylesheet">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap CSS -->
<!-- Bootstrap JS, Popper.js, and jQuery -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.2/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bignumber.js/9.0.2/bignumber.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <meta charset="UTF-8">
    <title>Add Liquidity to SushiSwap Trident Pool</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"></script>
</head>
<body>
	<div class="backgroundzzzz">
    <!-- Navigation -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="index.html" target="_self" aria-label="FORGE"><img alt="FORGE" src="img/forgeprofile circle-02.png" width="100px" height="110px" class="img-responsive"></a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right"> <li>
                        <a href="/" style="font-size:1.1em">2Home</a>
                    </li>
                  <li>
                    <a href="https://evm-9wzybb6h4.sushi.com/swap?fromChainId=42161&fromCurrency=NATIVE&toChainId=42161&toCurrency=0x0B549125fbEA37E52Ee05FA388a3A0a7Df792Fa7&amount=0.0000001&chainId=42161&token0=NATIVE&token1=0x0B549125fbEA37E52Ee05FA388a3A0a7Df792Fa7&swapAmount=0.01" style="font-size:1.1em">Buy ABAS</a>
                </li>     
                    <!--an ordered list stan made me remove 3 times-->
                   <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" style="font-size:1.25em">Liquidity<b class="caret"></b></a>
                        <ul class="dropdown-menu">

                            <li>
                                <a href="addLiq.html"style="font-size:1.1em">Add Liquidity to ABAS/ETH</a>
                            </li>
                            <li>
                                <a href="removeLiq.html"style="font-size:1.1em">Remove Liquidity from ABAS/ETH</a>
                            </li>

                        </ul>
                    </li>
                    <li>
                        <a href="/dapp/" style="font-size:1.1em">DAPP - Stake & Auctions</a>
                    </li>
                    <li>
                        <a href="stats.html"style="font-size:1.1em">Token Stats</a>
                    </li>                    
                    <!--an ordered list stan made me remove 3 times-->
                   <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" style="font-size:1.25em">ABAS Instructions<b class="caret"></b></a>
                        <ul class="dropdown-menu">

                            <li>
                                <a href="whitepaper.html"style="font-size:1.1em">Whitepaper</a>
                            </li>
                            <li>
                                <a href="howtoauction.html"style="font-size:1.1em">How to Auction</a>
                            </li>
                            <li>
                                <a href="howtostake.html"style="font-size:1.1em">How to Stake</a>
                            </li>
                            <li>10
                                <a href="howtomine.html"style="font-size:1.1em">How to Mine</a>
                            </li>
                            <li>
                                <a href="team.html"style="font-size:1.1em">Contact Us</a>
                            </li>
                        </ul>
                    </li>
                        </ul>
            </div>
            <!-- class /.navbar-collapse -->
        </div>
        <!-- class /.container -->
    </nav>
     <div class="container2">
	    <div class="column2 left-column">
		<h2>Left Section</h2>
		<p>This is the left section where you can place some information.</p>
		
	<div id="app2">	
		<h2>Round: {{currentRound}}</h2>
<button id="approveTokenBtnBNBTC" style="display: none;">Step 1) Approve BNBTC Token</button>
<button id="approveTokenBtnBNBTC2" style="display: none;">Step 2) Buy Tickets</button>

  <button id="buttonBuyTickets">Buy Tickets</button></br>
    <label for="buyTicket">Buy Ticket(s):</label>  
    <input id="button22" type="number" min="1" max="10" v-model.number="buyTicketAmount" placeholder="Ticket Amount">
   <div id="buyTicketAmt"> Total # of Tickets Sold: {{ TickestSold }}</div> 
   <div id="txLeft">Tickets Left: {{ (TotalTickets - TickestSold) }} </div>
   <div id="WinningChance">Winning Chance: {{ winningChance }}</div>
   <div id="Jackpot">Jackpot 800 BNBTC</div>
   <br></br>
   <div id="1StatBreakDown">80% Winning Ticket Holder</div>
 <div id="2StatBreakDown">10% BNBitcoin.BNB</div>
 <div id="3StatBreakDown">10% Application Developer</div>
   <br></br>
<button id="test-btn4">Test FETCH Winners CLICK</button>
<button id="test-btn5">Test FETCH Winners CLICK w/o Logs</button>

<div id="app23" class="image-container">
  <div v-for="(row, rowIndex) in displayedRows" :key="rowIndex">
    <div class="image-block">
      <h2>Round #{{ row.roundNumber }} Winner: {{ row.WinnerAddress.substring(0,14) }}  </h2>
    </div>
  </div></div>
  <button @click="prevPage" :hidden="currentPage <= 0">Previous</button>
  <button @click="nextPage" :hidden="(currentPage + 1) * rowsPerPage >= imageRows.length">Next</button>
</div>	
	    </div>
	    <div class="column2 middle-column">
		<h2>Middle Section</h2>
		<p>This is the middle section, ideal for primary content or more detailed information.</p>
		
		
<div id="YourAddressbsc">Your connected BSC address: ? Connect Wallet</div>
		
<div id="YourBalanceBNBTC">Your BNBTC Balance: ? Connect Wallet</div>
<div id="YourBalanceBNB">Your BNB Balance: ? Connect Wallet</div>
<div id="YourAllowanceBNBTC">Your BNBTC Allowance: ? Connect Wallet</div>
    <button id="getTestnetTokens">Get BNBTC Test Tokens (Testnet Only)</button><br>
   	
<div id="reloadID">Stats will reload in 20 seconds</div>
<div id="reloadID2">Stats2 will reload in 20 seconds</div>
	
   
	    </div>
	    <div class="column2 right-column">
		<h2>Right Section - Results</h2>
		
    <button id="GetLottoTotal">Get Total Lottery winnings </button><br>
    <button id="claimWinnings">Claim Winnings</button><br>
<div id="LottoWinnings">Lottery winnings: ? Connect Wallet</div>
      

<button id="test-btn3">Test Fetch Your Results</button>

<div id="app">
  <div class="image-container">
    <div v-for="(row, rowIndex) in displayedRows" :key="rowIndex">
      <div class="image-block">
        <h2>Round #{{ row.roundNumber }}</h2>
      </div>
      <div class="image-row">
        <img v-for="(image, index) in row.images" :key="index" :src="image.url" alt="Dynamic Image">
      </div>
    </div>
  </div>
  <div class="buttonsstuff">
    <button @click="prevPage" :hidden="currentPage <= 0">Previous</button>
    <button @click="nextPage" :hidden="(currentPage + 1) * rowsPerPage >= imageRows.length">Next</button>
  </div>
</div>




    </div>
	    </div>
</div>

</div>
        </body>
            <footer id="footer.dark taz"> 
          <div class="container">
            <div class="row" >
                <div class="col-sm-6 col-md-3 item">
                   </div>
                <div class="col-sm-6 col-md-3 item">
                    <h3>About</h3>
                    <ul>
                        <li><a href="howtomine.html">How to Mine</a></li>
                        <li><a href="whitepaper.html">Whitepaper</a></li>
                        <li><a href="team.html">Contact Us</a></li>
                    </ul>
                </div>
                
                <div class="col-md-6 item text">
                    <h3>zkBitcoin</h3>
                    <h5>A new way to DEFI. Mine it yourself with your GPU/FPGA/ASIC miner!!  All decentralized!!</h5>
                </div>
                <div class="col item">
                    <a href="https://t.me/zkBitcoinToken" aria-label="Telegram">
                  <i class="fa fa-telegram zeropadding"></i></a>
                    <a href="https://twitter.com/zkBitcoinToken/" aria-label="Twitter">
                  <i class="fa fa-twitter zeropadding"></i></a>
                    <a href="https://medium.com/@zkBitcoinToken/" aria-label="Medium">  
                  <i class="fa fa-medium zeropadding"></i></a>
                    <a href="https://github.com/ZKBitcoinToken" aria-label="Github">  
                  <i class="fa fa-github zeropadding"></i></a>
                    <a href="https://discord.gg/dNKbmFvvJU" aria-label="Discord">  
                  <i class="">Join Our Discord</i></a></div>
            </div>
        </div>
</footer> 


    <script type="text/javascript">
    
   const app = new Vue({
  el: '#app',
  data() {
    return {
      imageRows: [
      ],
      imageRows2: [
        {roundNumber: 32, images: new Array(10).fill(null).map(() => ({ url: 'http://127.0.0.1:8080/img/image1.jpg' }))},
        {roundNumber: 31, images: new Array(10).fill(null).map((_, index) => ({ url: `http://127.0.0.1:8080/img/image${index + 1}g.png` }))}
      ], 
      currentPage: 0,
      rowsPerPage: 3,
	  contractABI: ["function currentRound() public view returns (uint256)"],
      swapImageName: 'http://127.0.0.1:8080/img/zkBitcoin.png',
      provider: null,
      winnerImages: 'http://127.0.0.1:8080/img/image1.jpg',
      contractAddress: '0xE419ccAB63605A8eE6b25Ee84b2eEb7e22D78635',
      abi: [{
  "anonymous": false,
  "inputs": [
    {"indexed": true, "name": "winner", "type": "address"},
    {"indexed": false, "name": "ticketNumber", "type": "uint256"},
    {"indexed": false, "name": "roundId", "type": "uint256"}
  ],
  "name": "WinnerSelected",
  "type": "event"
}
],
      contract: null,
      reloadCounter: 20 // Counter to track the countdown seconds
    };
  },
  computed: {
    reversedImageRows() {
      return [...this.imageRows].reverse(); // Create a copy and reverse it
      },
      displayedRows() {
      const start = this.currentPage * this.rowsPerPage;
      const end = start + this.rowsPerPage;
      return [...this.imageRows].slice(start, end);
    }
  },
  mounted() {
    this.initializeEthereum();
    this.fetchAuctions();
    
    
    // Update the counter every second
    setInterval(() => {
    document.getElementById('reloadID').innerText = `Stats will reload in ${this.reloadCounter} seconds`;
      if (this.reloadCounter > 0) {
        this.reloadCounter--;
      } else {
        this.fetchAuctions();
        this.reloadCounter = 20; // Reset the counter after reload
      }
    }, 1000);
    
    
    
  },
  methods: {
    swapImage(rowIndex, imageIndex) {
      this.imageRows[rowIndex].images[imageIndex].url = this.swapImageName;
    },
    swapImage2(rowIndex, imageIndex) {
		var test123123 = imageIndex + 1
		this.imageRows[rowIndex].images[imageIndex].url = `https://untouchable2k.github.io/img/lotteryBalls/${test123123}g.png`;
    },
    async addImageRow(newRow) {
      this.imageRows.push(newRow);
    },
    testOutside(rowIndex, imageIndex) {
      this.swapImage(rowIndex, imageIndex);  // This swaps the image in the specified row and index.

      // Create a new row object with the roundNumber incremented and new images array
      const newRoundNumber = this.imageRows[rowIndex].roundNumber + 1;
      const newImages = this.imageRows[rowIndex].images.map(image => {
        return { url: this.swapImageName };  // Set the swap image for each image in the new row
      });

      // Add the new row at the beginning of the imageRows array
      this.addImageRow({ roundNumber: newRoundNumber, images: newImages });
    },
    async testInside(rowIndex, imageIndex, roundNumber, tickets) {
    
     let newImagesfff = new Array(10).fill(null).map((_, index) => ({
    url: `https://untouchable2k.github.io/img/lotteryBalls/${index + 1}n.png`
  }));

    console.log("This: ", tickets);
          tickets.forEach(ticket => {
        if (ticket >= 1 && ticket <= 10) {
          newImagesfff[ticket - 1] = {  url: `https://untouchable2k.github.io/img/lotteryBalls/${ticket}r.png` }
        }
      });
      
      
	var test = rowIndex -1;
      // Create a new row object with the roundNumber incremented and new images array
      const newRoundNumber = roundNumber;
      const newImages = new Array(10).fill(null).map((_, index) => ({ url: `https://untouchable2k.github.io/img/lotteryBalls/${index + 1}r.png` }));  // Set the swap image for each image in the new row
      
      console.log("Round Number : ", roundNumber);
      if(this.imageRows.length  < 1 ){
      
      
	      await this.addImageRow({ roundNumber: newRoundNumber, images: newImagesfff });
	      this.swapImage2(test, imageIndex);  // This swaps the image in the specified row and index.
      
      }else if(roundNumber < this.imageRows[this.imageRows.length-1].roundNumber){
	
      console.log("Prev round Number: ", this.imageRows[this.imageRows.length-1].roundNumber);
	      // Add the new row at the beginning of the imageRows array
	      await this.addImageRow({ roundNumber: newRoundNumber, images: newImagesfff });
	      this.swapImage2(test, imageIndex);  // This swaps the image in the specified row and index.
	}
    },
    async testInside2f(rowIndex, imageIndex, roundNumber, tickets) {
    
     let newImagesfff = new Array(10).fill(null).map((_, index) => ({
    url: `https://untouchable2k.github.io/img/lotteryBalls/${index + 1}n.png`
  }));

    console.log("This: ", tickets);
          tickets.forEach(ticket => {
        if (ticket >= 1 && ticket <= 10) {
          newImagesfff[ticket - 1] = {  url: `https://untouchable2k.github.io/img/lotteryBalls/${ticket}r.png` }
        }
      });
      
	var test = rowIndex -1;
      // Create a new row object with the roundNumber incremented and new images array
      const newRoundNumber = roundNumber;
      const newImages = new Array(10).fill(null).map((_, index) => ({ url: `https://untouchable2k.github.io/img/lotteryBalls/${index + 1}r.png` }));  // Set the swap image for each image in the new row
      
      console.log("Round Number : ", roundNumber);
      if(this.imageRows.length  < 1 && tickets.length !=0 ){
      
      
	      await this.addImageRow({ roundNumber: newRoundNumber, images: newImagesfff });
	      //this.swapImage2(test, imageIndex);  // This swaps the image in the specified row and index.
      
      }else if(roundNumber < this.imageRows[this.imageRows.length-1].roundNumber  && tickets.length !=0 ){
	
      console.log("Prev round Number: ", this.imageRows[this.imageRows.length-1].roundNumber);
	      // Add the new row at the beginning of the imageRows array
	      await this.addImageRow({ roundNumber: newRoundNumber, images: newImagesfff });
	      //this.swapImage2(test, imageIndex);  // This swaps the image in the specified row and index.
	}
    },
    nextPage() {
      if ((this.currentPage + 1) * this.rowsPerPage < this.imageRows.length) {
        this.currentPage++;
      }
    },
    prevPage() {
      if (this.currentPage > 0) {
        this.currentPage--;
      }
    },
    initializeEthereum() {
      // Set up a provider
      this.provider = new ethers.providers.JsonRpcProvider('https://bsc-testnet-rpc.publicnode.com');

      // Create a contract instance
      this.contract = new ethers.Contract(this.contractAddress, this.abi, this.provider);
    },
    async getCurrentBlock() {
      try {
        const currentBlock = await this.provider.getBlockNumber();

        console.log('Current Block:', currentBlock);
        return currentBlock;

        // Use targetBlock as needed, e.g., fetching logs from this block onwards
      } catch (error) {
        console.error('Error getting block number:', error);
      }
    },
    async fetchLogs() {
      try {
        var blockNumz = await this.getCurrentBlock();
        var Minus = blockNumz - 40000;
        const logs = await this.provider.getLogs({
          fromBlock: Minus,
          toBlock: blockNumz,
          address: this.contractAddress,
          topics: ["0x2f1b5357ef4ab89f6b09b3fa72e170d4648af7252951a8549dee6c3924baa4f1"]
        });




	for(var x=0; x< logs.length; x++){
		
		console.log(logs);
		var dataz = logs[x].data;
		console.log("zero data: ", dataz);
		console.log("zero data: ", dataz.substring(0,66));
		console.log("zero data2: ", dataz.substring(67,131));
		var start = this.imageRows.length +1;
		var variable = parseInt(dataz.substring(0,66));
		var roundID = parseInt(dataz.substring(67,131));
		console.log("data 0 variable: ", variable);
		console.log("data 0 roundID: ", roundID);
		console.log("data 0 start: ", start);
	//	this.testInside(start, variable-1, roundID);
		// Process logs or update data
	}
      } catch (error) {
      
        console.error('Error fetching logs:', error);
      }
    },
    async connectWallet() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    const { chainId } = await provider.getNetwork();
            	     userAddy = await signer.getAddress();
                    document.getElementById('YourAddressbsc').innerText = `Your connected address: ${userAddy}`;
                    if (chainId !== 97) { // Check if the chain ID is not 324
                                        alert('You are on the wrong network. Please switch to the correct network. BSC Tesnet, ChainID: 97');
                                        // Optionally, try to switch the user's network using window.ethereum.request
                                        return;
                    }
                    console.log("Wallet connected");
                } catch (error) {
                    console.error("Error connecting to wallet:", error);
                }
            } else {
                alert('MetaMask is not installed. Please install it to use this feature.');
            }
	},async fetchAuctions() {
     await connectWallet();
      try {
      
        this.imageRows = [];
      const contract = new ethers.Contract(this.contractAddress, this.contractABI, this.provider);
      const round = await contract.currentRound();
  	console.log("Current Round:", round.toString());
  	this.currentRound = parseInt(round);
        var blockNumz = await this.getCurrentBlock();
        var Minus = blockNumz - 40000;
        const logs = await this.provider.getLogs({
          fromBlock: Minus,
          toBlock: blockNumz,
          address: this.contractAddress,
          topics: ["0x2f1b5357ef4ab89f6b09b3fa72e170d4648af7252951a8549dee6c3924baa4f1"]
        });

	const getWinnersABI = [{
	    "constant": true,
	    "inputs": [],
	    "name": "getWinners",
	    "outputs": [
		{
		    "internalType": "address[]",
		    "name": "winners",
		    "type": "address[]"
		},
		{
		    "internalType": "uint32[]",
		    "name": "tickets",
		    "type": "uint32[]"
		},
		{
		    "internalType": "bool[]",
		    "name": "rewardsDistributed",
		    "type": "bool[]"
		}
	    ],
	    "payable": false,
	    "stateMutability": "view",
	    "type": "function"
	},
	{
    "constant": true,
    "inputs": [
      {
        "name": "buyer",
        "type": "address"
      },
      {
        "name": "round",
        "type": "uint256"
      }
    ],
    "name": "getTicketsOfBuyerForRound",
    "outputs": [
      {
        "name": "",
        "type": "uint32[]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "buyer",
        "type": "address"
      }
    ],
    "name": "getTicketsOfBuyer",
    "outputs": [
      {
        "name": "",
        "type": "uint256[]"
      },
      {
        "name": "",
        "type": "uint32[][]"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
  ];
	const contract2 = new ethers.Contract(this.contractAddress, getWinnersABI, this.provider);
      
	const { winners, tickets, rewardsDistributed } = await contract2.getWinners();
        var winners2 = winners;
        var ticketsTot2 = tickets;
        var rewardDist2 = rewardsDistributed;
        var test = await contract2.getTicketsOfBuyer(userAddy);
        console.log("Testing test3: ", test);
        console.log("user addy: ", userAddy);
        console.table(test);
        console.table("FFFFFFFF L : ", test[1][2]);


        console.log("Testing ", test[1].length);
	var roundstouse =new Array(0);
	var ticketsff = [];
	for(var y=0; y< test[0].length; y++){
		roundstouse.push(test[0][y]);
		  ticketsff[y] = []; // Initialize an empty array at each index of ticketsff
		for(var z=0; z<test[1][y].length; z++){
			ticketsff[y].push(test[1][y][z]);
		}
		console.log("Round: ",parseInt(roundstouse[y]), " tickets: ", ticketsff);
	}
	for(var x=roundstouse.length - 1; x>=0; x--){
		if(ticketsff[x].length != 0){
			var ticketsBought = await contract2.getTicketsOfBuyerForRound(userAddy, roundstouse[x]);
	
		
		//for(var x=parseInt(round)-1; x>=0; x--){
			console.log("Contract2: ", contract2);
			
		//	var ticketsBought = await contract2.getTicketsOfBuyerForRound(userAddy, x);
			console.log("User to check for: ", userAddy);
			console.log("WHAT DID WE BUY FOR ROUND:x:  ",x," : Tickets: ",ticketsBought );
			//var winnerz = logs[x].topics[1].substring(26,66);
			//var winnerzWhole = logs[x].topics[1];
			//console.log("Winer: ",winnerz);
			//console.log("Winer W:  ",winnerzWhole);
			//winnerz = "0x"+winnerz;
			//var dataz = logs[x].data;
			//console.log("zero data: ", dataz);
			//console.log("zero data: ", dataz.substring(0,66));
			//console.log("zero data2: ", dataz.substring(67,131));
			var start = this.imageRows.length +1;
			var variable = 1;
			var roundID = x;
			console.log("data 0 start: ", start);
			console.log("data 0 ticketsTot2: ", ticketsTot2[x]);
			console.log("data 0 x: ", x);
			console.log("signer: ", signer);
			
			if(winners2[x] == userAddy){
			
			this.testInside(start, ticketsTot2[x]-1, x, ticketsBought);
			}else{
			
			this.testInside2f(start, ticketsTot2[x]-1, x, ticketsBought);
			}
		//this.testInside(start, variable-1, roundID, winnerz);
		// Process logs or update data
		}
	}
      } catch (error) {
      
        console.error('Error fetching logs:', error);
      }
    }
  }
});
    
    
    
    
    document.getElementById('test-btn3').addEventListener('click', function() {
    app.fetchAuctions(); // Call the method with specific parameters
  });
    
    
    
    
    
    
    
   const app2 = new Vue({
  el: '#app2',
  data() {
    return {
      imageRows: [
      ], 
      imageRows2: [
        {roundNumber: -1, images: new Array(10).fill(null).map(() => ({ url: 'http://127.0.0.1:8080/img/image1.jpg' })),WinnerAddress: "0x012301230012303888888"},
        {roundNumber: -2, images: new Array(10).fill(null).map(() => ({ url: 'http://127.0.0.1:8080/img/image1.jpg' })),WinnerAddress: "0x012301230012303888888"}
      ], 
      currentPage: 0,
      rowsPerPage: 3,
      swapImageName: 'http://127.0.0.1:8080/img/zkBitcoin.png',
      provider: null,
      provider2: null,
      winnerImages: 'http://127.0.0.1:8080/img/image1.jpg',
      contractAddress: '0xE419ccAB63605A8eE6b25Ee84b2eEb7e22D78635',
      TokencontractAddress: '0x59984dBdda327dAF68285a896ACe398A739F80c3',
      totalTicketsSold: 0,
      buyTicketAmount: 1, // Set initial value here
      maxTickets: 10,
      approvalAmt: 0,
      contractABI: ["function currentRound() public view returns (uint256)",],
      contract: null,
      currentRound: 0,
	  signer2: "",
		TickestSold: 0,
		TotalTickets: 0,
	ticketPrice: 0,
	reloadCounter2: 20,
		
    };
  },
  computed: {
	    reversedImageRows() {
	      return [...this.imageRows].reverse(); // Create a copy and reverse it
	      },
	      displayedRows() {
	      const start = this.currentPage * this.rowsPerPage;
	      const end = start + this.rowsPerPage;
	      return [...this.imageRows].reverse().slice(start, end);
	    },
	    
    ticketsLeft() {
      return this.maxTickets - this.totalTicketsSold;
    },
    winningChance() {
      let chance = (this.buyTicketAmount / 10) * 100;
      return `${chance.toFixed(2)}%`;
    }
  },
  mounted() {
    this.initializeEthereum();
    this.fetchAuctions();
    this.GetStats();
    this.getAuctionTotal();
    
    
     
    // Update the counter every second
    setInterval(() => {
    document.getElementById('reloadID2').innerText = `Stats will reload in ${this.reloadCounter2} seconds`;
      if (this.reloadCounter2 > 0) {
        this.reloadCounter2--;
      } else {
        this.fetchAuctions();
        this.GetStats();
        this.getAuctionTotal();
        this.reloadCounter2 = 20; // Reset the counter after reload
      }
    }, 1000);
    
    
    
    
    
  },
  methods: {
    swapImage(rowIndex, imageIndex) {
      this.imageRows[rowIndex].images[imageIndex].url = this.swapImageName;
    },
    swapImage2(rowIndex, imageIndex) {
      this.imageRows[rowIndex].images[imageIndex].url = this.winnerImages;
    },
    async addImageRow(newRow) {
      this.imageRows.push(newRow);
    },
    async testInside(rowIndex, imageIndex, roundNumber, winnerz) {
	var test = rowIndex -1;
      // Create a new row object with the roundNumber incremented and new images array
      const newRoundNumber = roundNumber;

      console.log("Round Number : ", roundNumber);
      if(this.imageRows.length < 1){
      
      
	      await this.addImageRow({ roundNumber: newRoundNumber, WinnerAddress: winnerz });
      
	}else if(roundNumber > this.imageRows[this.imageRows.length-1].roundNumber){
	
      console.log("Prev round Number: ", this.imageRows[this.imageRows.length-1].roundNumber);
	      // Add the new row at the beginning of the imageRows array
	      await this.addImageRow({ roundNumber: newRoundNumber, WinnerAddress: winnerz });
	}
    },
    nextPage() {
      if ((this.currentPage + 1) * this.rowsPerPage < this.imageRows.length) {
        this.currentPage++;
      }
    },
    prevPage() {
      if (this.currentPage > 0) {
        this.currentPage--;
      }
    },
    initializeEthereum() {
      // Set up a provider
      this.provider = new ethers.providers.JsonRpcProvider('https://bsc-testnet-rpc.publicnode.com');

      // Create a contract instance
      this.contract = new ethers.Contract(this.contractAddress, this.contractABI, this.provider);
    },
    async getCurrentBlock() {
      try {
        const currentBlock = await this.provider.getBlockNumber();

        console.log('Current Block:', currentBlock);
        return currentBlock;

        // Use targetBlock as needed, e.g., fetching logs from this block onwards
      } catch (error) {
        console.error('Error getting block number:', error);
      }
    },
    async fetchLogs() {
      try {
        var blockNumz = await this.getCurrentBlock();
        var Minus = blockNumz - 40000;
        const logs = await this.provider.getLogs({
          fromBlock: Minus,
          toBlock: blockNumz,
          address: this.contractAddress,
          topics: ["0x2f1b5357ef4ab89f6b09b3fa72e170d4648af7252951a8549dee6c3924baa4f1"]
        });




	for(var x=0; x< logs.length; x++){
		
		console.log(logs);
		var winnerz = logs[x].topics[1].substring(26,66);
		var winnerzWhole = logs[x].topics[1];
		console.log("Winer: ",winnerz);
		console.log("Winer W:  ",winnerzWhole);
		winnerz = "0x"+winnerz;
		var dataz = logs[x].data;
		console.log("zero data: ", dataz);
		console.log("zero data: ", dataz.substring(0,66));
		console.log("zero data2: ", dataz.substring(67,131));
		var start = this.imageRows.length +1;
		var variable = parseInt(dataz.substring(0,66));
		var roundID = parseInt(dataz.substring(67,131));
		console.log("data 0 variable: ", variable);
		console.log("data 0 roundID: ", roundID);
		console.log("data 0 start: ", start);
		this.testInside(start, variable-1, roundID, winnerz);
		// Process logs or update data
	}
      } catch (error) {
      
        console.error('Error fetching logs:', error);
      }
    },
    async connectWallet() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    this.provider2 = new ethers.providers.Web3Provider(window.ethereum);
                    this.signer2 = this.provider2.getSigner();
                    const { chainId } = await this.provider2.getNetwork();
            	     userAddy = await this.signer2.getAddress();
            	     
                    document.getElementById('YourAddressbsc').innerText = `Your connected address: ${userAddy}`;
                    if (chainId !== 97) { // Check if the chain ID is not 324
                                        alert('You are on the wrong network. Please switch to the correct network. BSC Tesnet, ChainID: 97');
                                        // Optionally, try to switch the user's network using window.ethereum.request
                    }
                    console.log("Wallet connected");
                } catch (error) {
                    console.error("Error connecting to wallet:", error);
                }
            } else {
                alert('MetaMask is not installed. Please install it to use this feature.');
            }
        },
    async fetchAuctions() {
     await connectWallet();
      try {
      console.log("CHECK IMAGE ROWS: ", this.imageRows);
      this.imageRows=[];
      const contract = new ethers.Contract(this.contractAddress, this.contractABI, this.provider);
      const round = await contract.currentRound();
  	console.log("Current Round:", round.toString());
  	this.currentRound = parseInt(round);
        var blockNumz = await this.getCurrentBlock();
        var Minus = blockNumz - 40000;
        const logs = await this.provider.getLogs({
          fromBlock: Minus,
          toBlock: blockNumz,
          address: this.contractAddress,
          topics: ["0x2f1b5357ef4ab89f6b09b3fa72e170d4648af7252951a8549dee6c3924baa4f1"]
        });

	const getWinnersABI = [{
	    "constant": true,
	    "inputs": [],
	    "name": "getWinners",
	    "outputs": [
		{
		    "internalType": "address[]",
		    "name": "winners",
		    "type": "address[]"
		},
		{
		    "internalType": "uint32[]",
		    "name": "tickets",
		    "type": "uint32[]"
		},
		{
		    "internalType": "bool[]",
		    "name": "rewardsDistributed",
		    "type": "bool[]"
		}
	    ],
	    "payable": false,
	    "stateMutability": "view",
	    "type": "function"
	}];
	const contract2 = new ethers.Contract(this.contractAddress, getWinnersABI, this.provider);
      
		  
		  const abi33	 = [
    {
        "constant": true,
        "inputs": [
            {"name": "index", "type": "uint256"}
        ],
        "name": "rounds",
        "outputs": [
            {"name": "maxTickets", "type": "uint256"},
            {"name": "soldTickets", "type": "uint256"},
            {"name": "ticketPrice", "type": "uint256"},
            {"name": "winnerReward", "type": "uint256"},
            {"name": "deployerReward", "type": "uint256"},
            {"name": "donationAmount", "type": "uint256"},
            {"name": "winnerAddress", "type": "address"},
            {"name": "winnerRewardPercentage", "type": "uint256"},
            {"name": "deployerRewardPercentage", "type": "uint256"}
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
];
		  const contract33 = new ethers.Contract(this.contractAddress, abi33, this.provider);
		      try {
        const data = await contract33.rounds(this.currentRound);
        console.log('Round Data:', data);
	    this.TickestSold = parseInt(data[1]);
	    this.TotalTickets = parseInt(data[0]);
		this.ticketPrice = parseInt(data[2]);
				  console.log("Tickets sold: ", parseInt(data[1]));
				  console.log("Tickets TotalTickets: ", parseInt(data[0]));
				  console.log("Tickets ticketPrice: ", parseInt(data[2]));
    } catch (error) {
        console.error('Error fetching round data:', error);
    }
	const { winners, tickets, rewardsDistributed } = await contract2.getWinners();
        var winners2 = winners;
        var ticketsTot2 = tickets;
        var rewardDist2 = rewardsDistributed;


	for(var x=0; x< parseInt(round); x++){
		console.log(logs);
		//var winnerz = logs[x].topics[1].substring(26,66);
		//var winnerzWhole = logs[x].topics[1];
		//console.log("Winer: ",winnerz);
		//console.log("Winer W:  ",winnerzWhole);
		//winnerz = "0x"+winnerz;
		//var dataz = logs[x].data;
		//console.log("zero data: ", dataz);
		//console.log("zero data: ", dataz.substring(0,66));
		//console.log("zero data2: ", dataz.substring(67,131));
		var start = this.imageRows.length +1;
		var variable = 1;
		var roundID = x;
		console.log("data 0 variable: ", variable);
		console.log("data 0 roundID: ", roundID);
		console.log("data 0 start: ", start);
		
		this.testInside(start, variable -1, x, winners2[x]);
		//this.testInside(start, variable-1, roundID, winnerz);
		// Process logs or update data
	}
      } catch (error) {
      
        console.error('Error fetching logs:', error);
      }
    },
	  async BuyTicketz(){
		  
		  
		const buyTicketsABI = [{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "numTickets",
				"type": "uint256"
			}
		],
		"name": "buyTickets",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	}];
		  
		   if (typeof window.ethereum !== 'undefined') {
		try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider2 = new ethers.providers.Web3Provider(window.ethereum);
                    signer2 = provider2.getSigner();
                    const { chainId } = await provider2.getNetwork();
            	     userAddy = await signer2.getAddress();
                    
					this.contract3 = new ethers.Contract(this.contractAddress, buyTicketsABI, signer2);
					
				// Estimate the gas limit
		const estimatedGasLimit = await this.contract3.estimateGas.buyTickets(this.buyTicketAmount);

		// Set the gas limit to 150% of the estimated gas limit
		const gasLimit = estimatedGasLimit.mul(3).div(2);
		
					console.log("Tickets to buy: ", this.buyTicketAmount);
        const transactionResponse = await this.contract3.buyTickets(this.buyTicketAmount, { gasLimit });
        await transactionResponse.wait();  // Wait for the transaction to be mined
        console.log('Tickets bought successfully');
					
                    console.log("Wallet connected");
                } catch (error) {
                    console.error("Error connecting to wallet:", error);
                }
            } else {
                alert('MetaMask is not installed. Please install it to use this feature.');
            }
		
	}  ,
	  async GetStats(){
		    
		   if (typeof window.ethereum !== 'undefined') {
                try {
                
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider2 = new ethers.providers.Web3Provider(window.ethereum);
                    signer2 = provider2.getSigner();
                    const { chainId } = await provider2.getNetwork();
            	     userAddy = await signer2.getAddress();
                    
                    document.getElementById('YourAddressbsc').innerText = `Your connected BSC address: ${userAddy}`;
                    document.getElementById('YourBalanceBNBTC').innerText = `Your BNBTC Balance: ${userAddy}`;
                    document.getElementById('YourBalanceBNB').innerText = `Your BNB Balance: ${userAddy}`;
                    document.getElementById('YourAllowanceBNBTC').innerText = `Your BNBTC Allowance: ${userAddy}`;
                    
                    const tokenAbi = [
    // balanceOf
    {
        "constant": true,
        "inputs": [{"name": "_owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "balance", "type": "uint256"}],
        "type": "function"
    },
    // allowance
    {
        "constant": true,
        "inputs": [{"name": "_owner", "type": "address"}, {"name": "_spender", "type": "address"}],
        "name": "allowance",
        "outputs": [{"name": "remaining", "type": "uint256"}],
        "type": "function"
    }
];
			const tokenAddress = this.TokencontractAddress; // Token Contract Address
			const walletAddress = userAddy; // Your wallet address
			const contractAddress = this.contractAddress; // The contract address to check approval
			var contractTT = new ethers.Contract(tokenAddress, tokenAbi, signer2);

			 try {
				// Get token balance
				const balanceBNBTC = await contractTT.balanceOf(walletAddress);
				const balBNBTCFormatted = ethers.utils.formatUnits(balanceBNBTC, 8);
				console.log(`Balance for ${contractAddress}: ${ethers.utils.formatUnits(balanceBNBTC, 8)} Tokens`);

				// Get allowance
      				  const allowance = await contractTT.allowance(walletAddress, contractAddress);
				const AllowanceFormatted = ethers.utils.formatUnits(allowance, 8);
				console.log(`Allowance for ${contractAddress}: ${ethers.utils.formatUnits(allowance, 8)} Tokens`);
				
    				const inputElement = document.getElementById('button22');
    				const buyTicketAmount2 = inputElement.value * this.buyTicketAmount;

    				const approveBtn = document.getElementById('approveTokenBtnBNBTC');
				const approveBtn2 = document.getElementById('approveTokenBtnBNBTC2');
				const approveBtn3 = document.getElementById('buttonBuyTickets');

				if (allowance.lt(buyTicketAmount2)) {
				    approveBtn.style.display = 'block';
				    approveBtn2.style.display = 'block';
				    approveBtn3.style.display = 'none';
				} else {
				    approveBtn.style.display = 'none';
				    approveBtn2.style.display = 'none';
				    approveBtn3.style.display = 'block';
				}
				const balanceBNB = await provider.getBalance(walletAddress);
				const balanceBNBFormatted = ethers.utils.formatUnits(balanceBNB, 18);
				console.log(`Allowance for ${contractAddress}: ${ethers.utils.formatUnits(balanceBNB, 18)} Tokens`);

                    document.getElementById('YourBalanceBNBTC').innerText = `Your BNBTC Balance: ${balBNBTCFormatted}`;
                    document.getElementById('YourAllowanceBNBTC').innerText = `Your BNBTC Allowance: ${AllowanceFormatted}`;
                    document.getElementById('YourBalanceBNB').innerText = `Your BNB Balance: ${balanceBNBFormatted}`;
			    } catch (error) {
				console.error(`Error2: ${error.message}`);
			    }
                    console.log('Tickets bought successfully');
					
                    console.log("Wallet connected");
                } catch (error) {
                    console.error("Error2 connecting to wallet:", error);
                }
            } else {
                alert('MetaMask is not installed. Please install it to use this feature.');
            }

	},
	  async approveBNBTC(){
		  
		  
		const approveBNBTCABI = [
    {
        "constant": false,
        "inputs": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            }
        ],
        "name": "approve",
        "outputs": [
            {
                "name": "",
                "type": "bool"
            }
        ],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    }
];

		  
		   if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider2 = new ethers.providers.Web3Provider(window.ethereum);
                    signer2 = provider2.getSigner();
                    const { chainId } = await provider2.getNetwork();
            	     userAddy = await signer2.getAddress();
                    
					this.contract3 = new ethers.Contract(this.TokencontractAddress, approveBNBTCABI, signer2);
					console.log("Amount to approve: 10000000000000000000000");
        const transactionResponse = await this.contract3.approve(this.contractAddress, "10000000000000000000000");
        await transactionResponse.wait();  // Wait for the transaction to be mined
        console.log('Approved BNBTC on Contract successfully');
					
                } catch (error) {
                    console.error("Error connecting to wallet to approve bnbtc on contract:", error);
                }
            } else {
                alert('MetaMask is not installed. Please install it to use this feature.');
            }
		
	},
	  async getTestnetTokens(){
		  
		  
		const getTestnetTokensABI = [
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "name": "withdrawToken",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }
];

		  
		   if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider2 = new ethers.providers.Web3Provider(window.ethereum);
                    signer2 = provider2.getSigner();
                    const { chainId } = await provider2.getNetwork();
            	     userAddy = await signer2.getAddress();
                    
					this.contract3 = new ethers.Contract(this.TokencontractAddress, getTestnetTokensABI, signer2);
					console.log("amount of test tokens to recieve: 1000000000000000");
        const transactionResponse = await this.contract3.withdrawToken("1000000000000000");
        await transactionResponse.wait();  // Wait for the transaction to be mined
        console.log('Recieved Testnet mBNBTC successfully');
					
                } catch (error) {
                    console.error("Error recieving mock bnbtc:", error);
                }
            } else {
                alert('MetaMask is not installed. Please install it to use this feature.');
            }
		
	},
	  async getAuctionTotal(){
		  
		  
		const getAuctionTotalABI =  [
    {
        "constant": true,
        "inputs": [
            {
                "name": "user",
                "type": "address"
            }
        ],
        "name": "smartClaimTotalAmount",
        "outputs": [
            {
                "name": "Rewardw",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    }
];

		  
		   if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider2 = new ethers.providers.Web3Provider(window.ethereum);
                    signer2 = provider2.getSigner();
                    const { chainId } = await provider2.getNetwork();
            	     userAddy = await signer2.getAddress();
                    
					contract33 = new ethers.Contract(this.contractAddress, getAuctionTotalABI, signer2);
					console.log("Checking users auctionTotal to recieve");
        const transactionResponse = await contract33.smartClaimTotalAmount(userAddy);

        console.log('Recieved Total Claim amount successfully');
        var totalFormatted = ethers.utils.formatUnits(transactionResponse, 8)
        
                    document.getElementById('LottoWinnings').innerText = `Lottery Winnings: ${totalFormatted} BNBTC`;
					
                } catch (error) {
                    console.error("Error recieving total claim a mount: ", error);
                }
            } else {
                alert('MetaMask is not installed. Please install it to use this feature.');
            }
		
	},
	  async getClaimLotto(){
		  
		  
		const getClaimLottoABI =  [
    {
        "constant": true,
        "inputs": [
            {
                "name": "user",
                "type": "address"
            }
        ],
        "name": "getArrayOfRoundsWinnersUnclaimed",
        "outputs": [
            {
                "type": "uint256[]",
                "name": "",
                "internalType": "uint256[]"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },{
        "constant": false,
        "inputs": [
            {
                "name": "roundIdzzzz",
                "type": "uint256[]"
            }
        ],
        "name": "withdrawRewardMultiArray",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    }
];

		  
		   if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider2 = new ethers.providers.Web3Provider(window.ethereum);
                    signer2 = provider2.getSigner();
                    const { chainId } = await provider2.getNetwork();
            	     userAddy = await signer2.getAddress();
                    
					contract33 = new ethers.Contract(this.contractAddress, getClaimLottoABI, signer2);
					console.log("Checking users auctionTotal to recieve");
        const transactionResponse = await contract33.getArrayOfRoundsWinnersUnclaimed(userAddy);
	console.log("Array of unclaimed lotto winnings: ",transactionResponse);
	
	
	  const transactionResponse2 = await contract33.withdrawRewardMultiArray(transactionResponse);
	
        await transactionResponse2.wait();  // Wait for the transaction to be mined
        console.log('Recieved Claim amount successfully');
        

					
                } catch (error) {
                    console.error("Error recieving total claim a mount: ", error);
                }
            } else {
                alert('MetaMask is not installed. Please install it to use this feature.');
            }
		
	}  
  }
});
    
    

    
    document.getElementById('GetLottoTotal').addEventListener('click', function() {
    app2.getAuctionTotal(); // Call the method with specific parameters
  });
    document.getElementById('claimWinnings').addEventListener('click', function() {
    app2.getClaimLotto(); // Call the method with specific parameters
  });
    document.getElementById('approveTokenBtnBNBTC').addEventListener('click', function() {
    app2.approveBNBTC(); // Call the method with specific parameters
  });
    document.getElementById('getTestnetTokens').addEventListener('click', function() {
    app2.getTestnetTokens(); // Call the method with specific parameters
  });
  
  
    
    document.getElementById('approveTokenBtnBNBTC2').addEventListener('click', function() {
    app2.BuyTicketz(); // Call the method with specific parameters
  });
    document.getElementById('buttonBuyTickets').addEventListener('click', function() {
    app2.BuyTicketz(); // Call the method with specific parameters
  });
    
    document.getElementById('test-btn4').addEventListener('click', function() {
    app2.fetchLogs(); // Call the method with specific parameters
  });
    
    document.getElementById('test-btn5').addEventListener('click', function() {
    app2.fetchAuctions(); // Call the method with specific parameters
  });
    
   
    
        let signer;
	let provider;
	let userAddy;
	let ratiozLP;
        const contractAddress = '0xD9988b4B5bBC53A794240496cfA9Bf5b1F8E0523';
        const contractABI = [
    {
        "constant": false,
        "inputs": [
            {
                "name": "tokenInput",
                "type": "tuple[]",
                "components": [
                    {"name": "token", "type": "address"},
                    {"name": "native", "type": "bool"},
                    {"name": "amount", "type": "uint256"}
                ]
            },
            {"name": "pool", "type": "address"},
            {"name": "minLiquidity", "type": "uint256"},
            {"name": "data", "type": "bytes"}
        ],
        "name": "addLiquidity",
        "outputs": [
            {"name": "liquidity", "type": "uint256"}
        ],
        "payable": true,
        "stateMutability": "payable",
        "type": "function"
    }
];

	const spenderAddress = '0x74c764D41B77DBbb4fe771daB1939B00b146894A';

        const tokenAddress = '0x0B549125fbEA37E52Ee05FA388a3A0a7Df792Fa7';
        const tokenABI = [
    {
        "inputs": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "tokens",
                "type": "uint256"
            }
        ],
        "name": "approve",
        "outputs": [
            {
                "name": "success",
                "type": "bool"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "name": "tokenOwner",
                "type": "address"
            }
        ],
        "name": "balanceOf",
        "outputs": [
            {
                "name": "balance",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
    "inputs": [
      {
        "name": "tokenOwner",
        "type": "address"
      },
      {
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "name": "remaining",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
];



        const LPtokenAddress = '0x911a89dE0430A5cE3699E57D508f8678Afa1fffc';
        const LPtokenABI = [
    {
        "inputs": [],
        "name": "getReserves",
        "outputs": [
            {"internalType": "uint112", "name": "_reserve0", "type": "uint112"},
            {"internalType": "uint112", "name": "_reserve1", "type": "uint112"},
            {"internalType": "uint32", "name": "_blockTimestampLast", "type": "uint32"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
    }
];








        const LPBENTOAddress = '0x74c764d41b77dbbb4fe771dab1939b00b146894a'; 
        const LPBENTOtokenABI = [
  {
    "inputs": [
      {
        "name": "",
        "type": "address"
      },
      {
        "name": "",
        "type": "address"
      }
    ],
    "name": "masterContractApproved",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "name": "user",
        "type": "address"
      },
      {
        "name": "masterContract",
        "type": "address"
      },
      {
        "name": "approved",
        "type": "bool"
      },
      {
        "name": "v",
        "type": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "setMasterContractApproval",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }];













        async function connectWallet() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    //document.getElementById('addLiquidityBtn').disabled = false;
                    const { chainId } = await provider.getNetwork();
            	     userAddy = await signer.getAddress();
                    document.getElementById('YourAddressbsc').innerText = `Your connected address: ${userAddy}`;
                    
                    if (chainId !== 97) { // Check if the chain ID is not 324
                                        alert('You are on the wrong network. Please switch to the correct network. BSC Tesnet, ChainID: 97');
                                        // Optionally, try to switch the user's network using window.ethereum.request
                    }
                    console.log("Wallet connected");
                } catch (error) {
                    console.error("Error connecting to wallet:", error);
                }
            } else {
                alert('MetaMask is not installed. Please install it to use this feature.');
            }
        }
        
        
        
        
        
    // Your existing conversion logic...

    </script>
</body>
</html>
 
